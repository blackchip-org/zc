<!-- Document generated by "gen-doc"; DO NOT EDIT -->

# int

Integer numbers

## Index

| Operation | Description
|-----------|------------
| [`add, a, +`](#add) | Addition
| [`add-ia`](#add-ia) | Addition, architecture-dependent integer
| [`add-i64`](#add-i64) | Addition, 64-bit integer
| [`add-i32`](#add-i32) | Addition, 32-bit integer
| [`add-i16`](#add-i16) | Addition, 16-bit integer
| [`add-i8`](#add-i8) | Addition, 8-bit integer
| [`add-ua`](#add-ua) | Addition, architecture-dependent unsigned integer
| [`add-u64`](#add-u64) | Addition, 64-bit unsigned integer
| [`add-u32`](#add-u32) | Addition, 32-bit unsigned integer
| [`add-u16`](#add-u16) | Addition, 16-bit unsigned integer
| [`add-u8`](#add-u8) | Addition, 8-bit unsigned integer
| [`div-int, d-int`](#div-int) | Euclidean division
| [`div-mod-int, dm-int`](#div-mod-int) | Euclidean division with modulus
| [`ia-max`](#ia-max) | Maximum architecture-dependant integer
| [`i64-max`](#i64-max) | Maximum 64-bit integer
| [`i32-max`](#i32-max) | Maximum 32-bit integer
| [`i16-max`](#i16-max) | Maximum 16-bit integer
| [`i8-max`](#i8-max) | Maximum 8-bit integer
| [`ia-min`](#ia-min) | Minimum architecture-dependant integer
| [`i64-min`](#i64-min) | Minimum 64-bit integer
| [`i32-max`](#i32-max) | Minimum 32-bit integer
| [`i16-min`](#i16-min) | Minimum 16-bit integer
| [`i8-min`](#i8-min) | Minimum 8-bit integer
| [`ua-max`](#ua-max) | Maximum architecture-dependant unsigned integer
| [`u64-max`](#u64-max) | Maximum 64-bit unsigned integer
| [`u32-max`](#u32-max) | Maximum 32-bit unsigned integer
| [`u16-max`](#u16-max) | Maximum 16-bit unsigned integer
| [`u8-max`](#u8-max) | Maximum 8-bit unsigned integer
| [`mod`](#mod) | Modulus
| [`mul, m, *`](#mul) | Multiplication
| [`mul-ia`](#mul-ia) | Multiplication, architecture-dependent integer
| [`mul-i64`](#mul-i64) | Multiplication, 64-bit integer
| [`mul-i32`](#mul-i32) | Multiplication, 32-bit integer
| [`mul-i16`](#mul-i16) | Multiplication, 16-bit integer
| [`mul-i8`](#mul-i8) | Multiplication, 8-bit integer
| [`mul-ua`](#mul-ua) | Multiplication, architecture-dependent unsigned integer
| [`mul-u64`](#mul-u64) | Multiplication, 64-bit unsigned integer
| [`mul-u32`](#mul-u32) | Multiplication, 32-bit unsigned integer
| [`mul-u16`](#mul-u16) | Multiplication, 16-bit unsigned integer
| [`mul-u8`](#mul-u8) | Multiplication, 8-bit unsigned integer
| [`neg`](#neg) | Negation
| [`pow, **`](#pow) | Exponentiation
| [`quo-int, q-int`](#quo-int) | Truncated division
| [`quo-rem-int, qr-int`](#quo-rem-int) | Truncated division with remainder
| [`rem`](#rem) | Remainder
| [`sign`](#sign) | Sign
| [`sqrt-int`](#sqrt-int) | Square root
| [`sub, s, -`](#sub) | Subtraction
| [`sub-ia`](#sub-ia) | Subtraction, architecture-dependent integer
| [`sub-i64`](#sub-i64) | Subtraction, 64-bit integer
| [`sub-i32`](#sub-i32) | Subtraction, 32-bit integer
| [`sub-i16`](#sub-i16) | Subtraction, 16-bit integer
| [`sub-i8`](#sub-i8) | Subtraction, 8-bit integer
| [`sub-ua`](#sub-ua) | Subtraction, architecture-dependent unsigned integer
| [`sub-u64`](#sub-u64) | Subtraction, 64-bit unsigned integer
| [`sub-u32`](#sub-u32) | Subtraction, 32-bit unsigned integer
| [`sub-u16`](#sub-u16) | Subtraction, 16-bit unsigned integer
| [`sub-u8`](#sub-u8) | Subtraction, 8-bit unsigned integer

## Operations

### add

Adds the value of *x* to *y*.

Aliases: `a`, `+`

Example:

<!-- test: add -->

| Input | Stack
|-------|------
| `6` | `6`
| `2` | `6 \| 2`
| `a` | `8`

### add-ia

Adds the value of *x* to *y*. If the result does not fit into an 
architecture-dependent integer, the value rolls over. 

```
( x:Int y:Int -- x:Int )
```

Example:

<!-- test: add-ia -->

| Input | Stack
|-------|------
| `ia-max 1 add-ia ia-min eq` | `true`

### add-i64

Adds the value of *x* to *y*. If the result does not fit into a
64-bit integer, the value rolls over. 

```
( x:Int64 y:Int64 -- x:Int64 )
```

Example:

<!-- test: add-i64 -->

| Input | Stack
|-------|------
| `0x7fffffffffffffff` | `0x7fffffffffffffff`
| `1` | `0x7fffffffffffffff \| 1`
| `add-i64` | `-9223372036854775808`

### add-i32

Adds the value of *x* to *y*. If the result does not fit into a
32-bit integer, the value rolls over. 

```
( x:Int32 y:Int32 -- x:Int32 )
```

Example:

<!-- test: add-i32 -->

| Input | Stack
|-------|------
| `0x7fffffff` | `0x7fffffff`
| `1` | `0x7fffffff \| 1`
| `add-i32` | `-2147483648`

### add-i16

Adds the value of *x* to *y*. If the result does not fit into a
64-bit integer, the value rolls over. 

```
( x:Int16 y:Int16 -- x:Int16 )
```

Example:

<!-- test: add-i16 -->

| Input | Stack
|-------|------
| `0x7fff` | `0x7fff`
| `1` | `0x7fff \| 1`
| `add-i16` | `-32768`

### add-i8

Adds the value of *x* to *y*. If the result does not fit into a
8-bit integer, the value rolls over. 

```
( x:Int8 y:Int8 -- x:Int8 )
```

Example:

<!-- test: add-i8 -->

| Input | Stack
|-------|------
| `0x7f` | `0x7f`
| `1` | `0x7f \| 1`
| `add-i8` | `-128`

### add-ua

Adds the value of *x* to *y*. If the result does not fit into an 
architecture-dependent unsigned integer, the value rolls over. 

```
( x:Uint y:Uint -- x:Uint )
```

Example:

<!-- test: add-ua -->

| Input | Stack
|-------|------
| `ua-max 1 add-ua` | `0`

### add-u64

Adds the value of *x* to *y*. If the result does not fit into a
64-bit unsigned integer, the value rolls over. 

```
( x:Uint64 y:Uint64 -- x:Uint64 )
```

Example:

<!-- test: add-u64 -->

| Input | Stack
|-------|------
| `0xffffffffffffffff` | `0xffffffffffffffff`
| `1` | `0xffffffffffffffff \| 1`
| `add-u64` | `0`

### add-u32

Adds the value of *x* to *y*. If the result does not fit into a
32-bit unsigned integer, the value rolls over. 

```
( x:Uint32 y:Uint32 -- x:Uint32 )
```

Example:

<!-- test: add-u32 -->

| Input | Stack
|-------|------
| `0xffffffff` | `0xffffffff`
| `1` | `0xffffffff \| 1`
| `add-u32` | `0`

### add-u16

Adds the value of *x* to *y*. If the result does not fit into a
64-bit unsigned integer, the value rolls over. 

```
( x:Uint16 y:Uint16 -- x:Uint16 )
```

Example:

<!-- test: add-u16 -->

| Input | Stack
|-------|------
| `0xffff` | `0xffff`
| `1` | `0xffff \| 1`
| `add-u16` | `0`

### add-u8

Adds the value of *x* to *y*. If the result does not fit into a
8-bit unsigned integer, the value rolls over. 

```
( x:Uint8 y:Uint8 -- x:Uint8 )
```

Example:

<!-- test: add-u8 -->

| Input | Stack
|-------|------
| `0xff` | `0xff`
| `1` | `0xff \| 1`
| `add-u8` | `0`

### div-int

Divides the value of *x* by *y* using Euclidean division. If *y* is zero, a 
division by zero error is raised. 

Alias: `d-int`

```
( x:BigInt y:BigInt -- x:BigInt )
```

Example:

<!-- test: div-int -->

| Input | Stack
|-------|------
| `-20` | `-20`
| `3` | `-20 \| 3`
| `div-int` | `-7`

### div-mod-int

Divides the value of *x* by *y* using Euclidean division and returns the
quotient *q* and the modulus *m*. If *y* is zero, a division by zero 
error is raised. 

Alias: `dm-int`

```
( x:BigInt y:BigInt -- x:BigInt y:BigInt )
```

Example:

<!-- test: div-mod-int -->

| Input | Stack
|-------|------
| `-20` | `-20`
| `3` | `-20 \| 3`
| `div-mod-int` | `-7 \| 1 # modulus`

### ia-max

Maximum architecture-dependant integer.

```
(  -- Int )
```

Example:

<!-- test: ia-max -->

| Input | Stack
|-------|------
| `ia-max 1 add-ia ia-min eq` | `true`

### i64-max

Maximum 64-bit integer.

```
def i64-max 9223372036854775807
```

Example:

<!-- test: i64-max -->

| Input | Stack
|-------|------
| `i64-max` | `9223372036854775807`

### i32-max

Maximum 32-bit integer.

```
def i32-max 2147483647
```

Example:

<!-- test: i32-max -->

| Input | Stack
|-------|------
| `i32-max` | `2147483647`

### i16-max

Maximum 16-bit integer.

```
def i16-max 32767
```

Example:

<!-- test: i16-max -->

| Input | Stack
|-------|------
| `i16-max` | `32767`

### i8-max

Maximum 8-bit integer.

```
def i8-max 127
```

Example:

<!-- test: i8-max -->

| Input | Stack
|-------|------
| `i8-max` | `127`

### ia-min

Minimum architecture-dependant integer.

```
(  -- Int )
```

Example:

<!-- test: ia-min -->

| Input | Stack
|-------|------
| `ia-min -1 add-ia ia-max eq` | `true`

### i64-min

Minimum 64-bit integer.

```
def i64-min -9223372036854775808
```

Example:

<!-- test: i64-min -->

| Input | Stack
|-------|------
| `i64-min` | `-9223372036854775808`

### i32-max

Minimum 32-bit integer.

```
def i32-max -2147483648
```

Example:

<!-- test: i32-max -->

| Input | Stack
|-------|------
| `i32-min` | `-2147483648`

### i16-min

Minimum 16-bit integer.

```
def i16-min -32768
```

Example:

<!-- test: i16-min -->

| Input | Stack
|-------|------
| `i16-min` | `-32768`

### i8-min

Minimum 8-bit integer.

```
def i8-min -128
```

Example:

<!-- test: i8-min -->

| Input | Stack
|-------|------
| `i8-min` | `-128`

### ua-max

Maximum architecture-dependant unsigned integer

```
(  -- UInt )
```

Example:

<!-- test: ua-max -->

| Input | Stack
|-------|------
| `ua-max 1 add-ua` | `0`

### u64-max

Maximum 64-bit unsigned integer.

```
def u64-max 18446744073709551615
```

Example:

<!-- test: u64-max -->

| Input | Stack
|-------|------
| `u64-max` | `18446744073709551615`

### u32-max

Maximum 32-bit unsigned integer.

```
def u32-max 4294967295
```

Example:

<!-- test: u32-max -->

| Input | Stack
|-------|------
| `u32-max` | `4294967295`

### u16-max

Maximum 16-bit unsigned integer.

```
def u16-max 65535
```

Example:

<!-- test: u16-max -->

| Input | Stack
|-------|------
| `u16-max` | `65535`

### u8-max

Maximum 8-bit unsigned integer.

```
def u8-max 255
```

Example:

<!-- test: u8-max -->

| Input | Stack
|-------|------
| `u8-max` | `255`

### mod

The modulus when *x* is divided by *y*. If *y* is zero, a 'division by
zero' error is raised.

Example:

<!-- test: mod -->

| Input | Stack
|-------|------
| `-7 2 mod` | `1`

### mul

Multiplies the value of *x* to *y*.

Aliases: `m`, `*`

Example:

<!-- test: mul -->

| Input | Stack
|-------|------
| `6` | `6`
| `2` | `6 \| 2`
| `m` | `12`

### mul-ia

Multiplies the value of *x* to *y*. If the result does not fit into an
architecture-independent integer, the value rolls over. 

```
( x:Int y:Int -- x:Int )
```

Example:

<!-- test: mul-ia -->

| Input | Stack
|-------|------
| `ia-max 2 mul-ia` | `-2`

### mul-i64

Multiplies the value of *x* to *y*. If the result does not fit into a
64-bit integer, the value rolls over. 

```
( x:Int64 y:Int64 -- x:Int64 )
```

Example:

<!-- test: mul-i64 -->

| Input | Stack
|-------|------
| `9,223,372,036,854,775,807` | `9,223,372,036,854,775,807`
| `2` | `9,223,372,036,854,775,807 \| 2`
| `mul-i64` | `-2`

### mul-i32

Multiplies the value of *x* to *y*. If the result does not fit into a
32-bit integer, the value rolls over. 

```
( x:Int32 y:Int32 -- x:Int32 )
```

Example:

<!-- test: mul-i32 -->

| Input | Stack
|-------|------
| `2,147,483,647` | `2,147,483,647`
| `2` | `2,147,483,647 \| 2`
| `mul-i32` | `-2`

### mul-i16

Multiplies the value of *x* to *y*. If the result does not fit into a
16-bit integer, the value rolls over. 

```
( x:Int16 y:Int16 -- x:Int16 )
```

Example:

<!-- test: mul-i16 -->

| Input | Stack
|-------|------
| `32,767` | `32,767`
| `2` | `32,767 \| 2`
| `mul-i16` | `-2`

### mul-i8

Multiplies the value of *x* to *y*. If the result does not fit into an
8-bit integer, the value rolls over. 

```
( x:Int8 y:Int8 -- x:Int8 )
```

Example:

<!-- test: mul-i8 -->

| Input | Stack
|-------|------
| `127` | `127`
| `2` | `127 \| 2`
| `mul-i8` | `-2`

### mul-ua

Multiplies the value of *x* to *y*. If the result does not fit into an
architecture-independent unsigned integer, the value rolls over. 

```
( x:Uint y:Uint -- x:Uint )
```

Example:

<!-- test: mul-ua -->

| Input | Stack
|-------|------
| `ua-max 2 mul-ua 1 add ua-max eq` | `true`

### mul-u64

Multiplies the value of *x* to *y*. If the result does not fit into a
64-bit unsigned integer, the value rolls over. 

```
( x:Uint64 y:Uint64 -- x:Uint64 )
```

Example:

<!-- test: mul-u64 -->

| Input | Stack
|-------|------
| `0xfedcba9876543210` | `0xfedcba9876543210`
| `0x10` | `0xfedcba9876543210 \| 0x10`
| `mul-u64 hex` | `0xedcba98765432100`

### mul-u32

Multiplies the value of *x* to *y*. If the result does not fit into a
32-bit unsigned integer, the value rolls over. 

```
( x:Uint32 y:Uint32 -- x:Uint32 )
```

Example:

<!-- test: mul-u32 -->

| Input | Stack
|-------|------
| `0xfedcba98` | `0xfedcba98`
| `0x10` | `0xfedcba98 \| 0x10`
| `mul-u32 hex` | `0xedcba980`

### mul-u16

Multiplies the value of *x* to *y*. If the result does not fit into a
16-bit unsigned integer, the value rolls over. 

```
( x:Uint16 y:Uint16 -- x:Uint16 )
```

Example:

<!-- test: mul-u16 -->

| Input | Stack
|-------|------
| `0xfedc` | `0xfedc`
| `0x10` | `0xfedc \| 0x10`
| `mul-u16 hex` | `0xedc0`

### mul-u8

Multiplies the value of *x* to *y*. If the result does not fit into an
8-bit unsigned integer, the value rolls over. 

```
( x:Uint8 y:Uint8 -- x:Uint8 )
```

Example:

<!-- test: mul-u8 -->

| Input | Stack
|-------|------
| `0xfe` | `0xfe`
| `0x10` | `0xfe \| 0x10`
| `mul-u8 hex` | `0xe0`

### neg

Changes the sign of *x*.

Example:

<!-- test: neg -->

| Input | Stack
|-------|------
| `-6` | `-6`
| `neg` | `6`
| `neg` | `-6`

### pow

Raises *x* to the power of *y*.

Alias: `**`

Example:

<!-- test: pow -->

| Input | Stack
|-------|------
| `6` | `6`
| `2` | `6 \| 2`
| `pow` | `36`

### quo-int

Divides the value of *x* by *y* using trunated division. If *y* is zero, a 
division by zero error is raised. 

Alias: `q-int`

```
( x:BigInt y:BigInt -- x:BigInt )
```

Example:

<!-- test: quo-int -->

| Input | Stack
|-------|------
| `-20` | `-20`
| `3` | `-20 \| 3`
| `quo-int` | `-6`

### quo-rem-int

Divides the value of *x* by *y* using truncated division and returns the
quotent *q* and the remainder *r*. If *y* is zero, a division by zero 
error is raised. 

Alias: `qr-int`

```
( x:BigInt y:BigInt -- x:BigInt y:BigInt )
```

Example:

<!-- test: quo-rem-int -->

| Input | Stack
|-------|------
| `-20` | `-20`
| `3` | `-20 \| 3`
| `quo-rem-int` | `-6 \| -2 # remainder`

### rem

The remainder when *x* is divided by *y* using truncated division. If *y* 
is zero, a 'division by zero' error is raised.

Example:

<!-- test: rem -->

| Input | Stack
|-------|------
| `-7` | `-7`
| `2` | `-7 \| 2`
| `rem` | `-1`

### sign

Returns `-1` if *x* is negative, `1` if *x* is positive, or `0` if *x*
is zero.

Example:

<!-- test: sign -->

| Input | Stack
|-------|------
| `c -6 sign` | `-1`
| `c 7 sign` | `1`
| `c 0 sign` | `0`

### sqrt-int

The floor of the square root of *x*. 

```
( x:BigInt -- x:BigInt )
```

Example:

<!-- test: sqrt-int -->

| Input | Stack
|-------|------
| `256` | `256`
| `sqrt-int` | `16`

### sub

Subtract the value of *x* from *y*.

Aliases: `s`, `-`

Example:

<!-- test: sub -->

| Input | Stack
|-------|------
| `6` | `6`
| `2` | `6 \| 2`
| `s` | `4`

### sub-ia

Subtracts the value of *y* from *x*. If the result does not fit into an 
architecture-dependent integer, the value rolls over. 

```
( x:Int y:Int -- x:Int )
```

Example:

<!-- test: sub-ia -->

| Input | Stack
|-------|------
| `ia-min 1 sub-ia ia-max eq` | `true`

### sub-i64

Subtracts the value of *y* from *x*. If the result does not fit into a
64-bit integer, the value rolls over. 

```
( x:Int64 y:Int64 -- x:Int64 )
```

Example:

<!-- test: sub-i64 -->

| Input | Stack
|-------|------
| `-9223372036854775808` | `-9223372036854775808`
| `1` | `-9223372036854775808 \| 1`
| `sub-i64` | `9223372036854775807`

### sub-i32

Subtracts the value of *y* from *x*. If the result does not fit into a
32-bit integer, the value rolls over. 

```
( x:Int32 y:Int32 -- x:Int32 )
```

Example:

<!-- test: sub-i32 -->

| Input | Stack
|-------|------
| `-2147483648` | `-2147483648`
| `1` | `-2147483648 \| 1`
| `sub-i32` | `2147483647`

### sub-i16

Subtracts the value of *y* from *x*. If the result does not fit into a
16-bit integer, the value rolls over. 

```
( x:Int16 y:Int16 -- x:Int16 )
```

Example:

<!-- test: sub-i16 -->

| Input | Stack
|-------|------
| `-32768` | `-32768`
| `1` | `-32768 \| 1`
| `sub-i16` | `32767`

### sub-i8

Subtracts the value of *y* from *x*. If the result does not fit into an
8-bit integer, the value rolls over. 

```
( x:Int8 y:Int8 -- x:Int8 )
```

Example:

<!-- test: sub-i8 -->

| Input | Stack
|-------|------
| `-128` | `-128`
| `1` | `-128 \| 1`
| `sub-i8` | `127`

### sub-ua

Subtracts the value of *y* from *x*. If the result does not fit into an 
architecture-dependent unsigned integer, the value rolls over. 

```
( x:Uint y:Uint -- x:Uint )
```

Example:

<!-- test: sub-ua -->

| Input | Stack
|-------|------
| `0 1 sub-ua ua-max eq` | `true`

### sub-u64

Subtracts the value of *y* from *x*. If the result does not fit into a
64-bit unsigned integer, the value rolls over. 

```
( x:Uint64 y:Uint64 -- x:Uint64 )
```

Example:

<!-- test: sub-u64 -->

| Input | Stack
|-------|------
| `0` | `0`
| `1` | `0 \| 1`
| `sub-u64` | `18446744073709551615`

### sub-u32

Subtracts the value of *y* from *x*. If the result does not fit into a
32-bit unsigned integer, the value rolls over. 

```
( x:Uint32 y:Uint32 -- x:Uint32 )
```

Example:

<!-- test: sub-u32 -->

| Input | Stack
|-------|------
| `0` | `0`
| `1` | `0 \| 1`
| `sub-u32` | `4294967295`

### sub-u16

Subtracts the value of *y* from *x*. If the result does not fit into a
16-bit unsigned integer, the value rolls over. 

```
( x:Uint16 y:Uint16 -- x:Uint16 )
```

Example:

<!-- test: sub-u16 -->

| Input | Stack
|-------|------
| `0` | `0`
| `1` | `0 \| 1`
| `sub-u16` | `65535`

### sub-u8

Subtracts the value of *x* to *y*. If the result does not fit into an
8-bit unsigned integer, the value rolls over. 

```
( x:Uint8 y:Uint8 -- x:Uint8 )
```

Example:

<!-- test: sub-u8 -->

| Input | Stack
|-------|------
| `0` | `0`
| `1` | `0 \| 1`
| `sub-u8` | `255`
