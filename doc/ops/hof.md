<!-- Document generated by "gen-doc"; DO NOT EDIT -->

# hof

Higher-order functions

| Operation         | Description
|-------------------|---------------
| [eval](#eval)     | Evaluate top of stack
| [filter](#filter) | Filter items in the stack
| [fold](#fold)     | Reduce items to a single value
| [map](#map)       | Apply a function to each item on the stack
| [repeat](#repeat) | Repeat the execution of a function


## eval

Evaluate *expr* as if it was input to the calculator.

	( Str* expr:Str -- Str* )

Example:

<!-- test: eval -->

| Input      | Stack
|------------|---------------
| `[1 2 add` | `1 2 add` 
| `eval    ` | `3` 

## filter

Filter the stack by keeping items that are true when evaluated by
expression *expr*.

	( Str* expr:Str -- Str* )

Example:

<!-- test: filter -->

| Input                 | Stack
|-----------------------|---------------
| `1 2 3 4 5 6        ` | `1 \| 2 \| 3 \| 4 \| 5 \| 6` 
| `[2 mod 0 eq] filter` | `2 \| 4 \| 6` 

## fold

Reduce the stack to a single value using the expression *expr*. An
'invalid function' error is raised if *expr* does not reduce.

Alias: `reduce`

	( Str* expr:Str -- Str )

Example:

<!-- test: fold -->

| Input        | Stack
|--------------|---------------
| `1 2 3 4 5 ` | `1 \| 2 \| 3 \| 4 \| 5` 
| `[add] fold` | `15` 

## map

Apply expression *expr* to each value in the stack.

	( Str* expr:Str -- Str* )

Example:

<!-- test: map -->

| Input         | Stack
|---------------|---------------
| `1 2 3 4 5  ` | `1 \| 2 \| 3 \| 4 \| 5` 
| `[2 mul] map` | `2 \| 4 \| 6 \| 8 \| 10` 

## repeat

Repeat execution of expression *expr* for *n* times.

	( Str* expr:Str n:Int -- Str* )

Example:

<!-- test: repeat -->

| Input              | Stack
|--------------------|---------------
| `1               ` | `1` 
| `[2 mul] 8 repeat` | `256` 
