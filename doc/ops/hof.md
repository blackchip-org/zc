<!-- Document generated by "gen-doc"; DO NOT EDIT -->
# hof

Higher-order functions

| Operation          | Description
|--------------------|---------------
| [`apply`](#apply)  | Apply a function using arguments on stack
| [`eval`](#eval)    | Evaluate top of stack
| [`filter`](#filter) | Filter items in the stack
| [`fold, reduce`](#fold) | Reduce items to a single value
| [`map`](#map)      | Apply a function to each item on the stack
| [`repeat`](#repeat) | Repeat the execution of a function


## apply

Evaluates the expression in *fn* by first popping *nargs* off the stack and
pushing them back as a single argument. This is useful for higher order
functions, like map, where some of the arguments are from existing results
found on the stack.

```
( args:Val* fn:Str nargs:Int -- Val* )
```

Example:

<!-- test: apply -->

| Input                      | Stack
|----------------------------|---------------
| `1 2 3 4                 ` | `1 \| 2 \| 3 \| 4`
| `n                       ` | `1 \| 2 \| 3 \| 4 \| 4 # size`
| `[swap sub] [map] 2 apply` | `3 \| 2 \| 1 \| 0`

## eval

Evaluate *expr* as if it was input to the calculator.

```
( expr:Str -- Val* )
```

Example:

<!-- test: eval -->

| Input      | Stack
|------------|---------------
| `[1 2 add` | `1 2 add`
| `eval    ` | `3`

## filter

Filter the stack by keeping items that are true when evaluated by
expression *expr*.

```
( Val* expr:Str -- Val* )
```

Example:

<!-- test: filter -->

| Input                 | Stack
|-----------------------|---------------
| `1 2 3 4 5 6        ` | `1 \| 2 \| 3 \| 4 \| 5 \| 6`
| `[2 mod 0 eq] filter` | `2 \| 4 \| 6`

## fold

Reduce the stack to a single value using the expression *expr*. An
'invalid function' error is raised if *expr* does not reduce.

Alias: `reduce`

```
( Val* expr:Str -- Val )
```

Example:

<!-- test: fold -->

| Input        | Stack
|--------------|---------------
| `1 2 3 4 5 ` | `1 \| 2 \| 3 \| 4 \| 5`
| `[add] fold` | `15`

## map

Apply expression *expr* to each value in the stack.

```
( Val* expr:Str -- Val* )
```

Example:

<!-- test: map -->

| Input         | Stack
|---------------|---------------
| `1 2 3 4 5  ` | `1 \| 2 \| 3 \| 4 \| 5`
| `[2 mul] map` | `2 \| 4 \| 6 \| 8 \| 10`

## repeat

Repeat execution of expression *expr* for *n* times.

```
( expr:Val n:Int -- Val* )
```

Example:

<!-- test: repeat -->

| Input              | Stack
|--------------------|---------------
| `1               ` | `1`
| `[2 mul] 8 repeat` | `256`
