package main

import (
	"fmt"
	"log"
	"os"
	"path"
	"strings"

	"github.com/blackchip-org/zc/pkg/doc"
)

//go:generate go run main.go

func main() {
	log.SetFlags(0)

	ops, err := doc.ParseSourceFiles("../../pkg/ops")
	if err != nil {
		log.Fatal(err)
	}

	groups := make(map[string]struct{})
	for _, op := range ops {
		groups[op.Group] = struct{}{}
	}
	for group := range groups {
		writeGroup(group, doc.FilterByGroup(ops, group))
	}
}

func writeGroup(group string, ops []doc.Op) {
	out := &strings.Builder{}
	table := doc.ByName(ops)
	names := doc.SortedNames(ops)

	fmt.Fprintf(out, "<!-- Document generated by \"gen-doc\"; DO NOT EDIT -->\n\n")
	fmt.Fprintf(out, "# %v\n\n", group)
	if groupTitle, ok := doc.GroupTitles[group]; ok {
		fmt.Fprintf(out, "%v\n\n", groupTitle)
	}

	width := 0
	for _, name := range names {
		w := len(name)*2 + 5
		if w > width {
			width = w
		}
	}

	fmt.Fprintf(out, "| %-[1]*v | Description\n", width, "Operation")
	fmt.Fprintf(out, "|%v|%v\n", strings.Repeat("-", width+2), strings.Repeat("-", 15))
	for _, name := range names {
		entry := fmt.Sprintf("[%v](#%v)", name, name)
		fmt.Fprintf(out, "| %-[1]*v | %v\n", width, entry, table[name].Title)
	}
	fmt.Fprintln(out, "")

	for _, name := range names {
		op := table[name]
		writeOp(out, op)
	}

	file := path.Join("../../doc/ops", group+".md")
	if err := os.WriteFile(file, []byte(out.String()), 0o644); err != nil {
		log.Fatalf("unable to write file: %v", err)
	}
}

func writeOp(out *strings.Builder, op doc.Op) {
	fmt.Fprintf(out, "\n## %v\n\n", op.Name)
	fmt.Fprintf(out, "%v\n\n", op.Desc)
	if len(op.Aliases) > 0 {
		if len(op.Aliases) == 1 {
			fmt.Fprintf(out, "Alias: ")
		} else {
			fmt.Fprintf(out, "Aliases: ")
		}
		var fmtAliases []string
		for _, a := range op.Aliases {
			fmtAliases = append(fmtAliases, fmt.Sprintf("`%v`", a))
		}
		fmt.Fprintf(out, "%v\n\n", strings.Join(fmtAliases, ", "))
	}
	for _, fn := range op.Funcs {
		fmt.Fprintf(out, "\t( ")
		var fmtParams []string
		for _, p := range fn.Params {
			fmtParams = append(fmtParams, p.String())
		}
		fmt.Fprintf(out, "%v -- ", strings.Join(fmtParams, " "))
		fmtParams = nil
		for _, p := range fn.Returns {
			fmtParams = append(fmtParams, p.String())
		}
		fmt.Fprintf(out, "%v )\n", strings.Join(fmtParams, " "))
	}
	fmt.Fprintln(out, "")
	if len(op.Example) > 0 {
		fmt.Fprintf(out, "Example:\n\n<!-- test: %v -->\n\n", op.Name)
		writeExample(out, op.Example)
	}
}

func writeExample(out *strings.Builder, expected []doc.Expect) {
	width := 0
	for _, ex := range expected {
		w := len(ex.In)
		if w > width {
			width = w
		}
	}

	fmt.Fprintf(out, "| %-[1]*v | Stack\n", width+2, "Input")
	fmt.Fprintf(out, "|%v|%v\n", strings.Repeat("-", width+4), strings.Repeat("-", 15))
	for _, ex := range expected {
		fmt.Fprintf(out, "| `%-[1]*v` | `%v` \n", width, ex.In, ex.Out)
	}
}
