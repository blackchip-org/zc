package main

//go:generate go run main.go

import (
	"fmt"
	"log"
	"os"
	"sort"
	"strings"

	"github.com/blackchip-org/zc/pkg/doc"
)

var prelude = strings.TrimSpace(`
// Code generated by "gen-ops"; DO NOT EDIT
package calc

import (
	"github.com/blackchip-org/zc/pkg/ops"
	"github.com/blackchip-org/zc/pkg/zc"
)

var opsList2 = []zc.OpDecl{
`)

var epilog = strings.TrimSpace(`
}
`)

func main() {
	log.SetFlags(0)

	ops, err := doc.ParseSourceFiles("../../pkg/ops")
	if err != nil {
		log.Fatal(err)
	}

	var names []string
	table := make(map[string]doc.Op)
	for _, op := range ops {
		other, ok := table[op.Name]
		if ok {
			other.Aliases = append(other.Aliases, op.Aliases...)
			other.Funcs = append(other.Funcs, op.Funcs...)
		} else {
			table[op.Name] = op
			names = append(names, op.Name)
		}
	}
	sort.Strings(names)

	out := &strings.Builder{}
	fmt.Fprintf(out, "%v\n", prelude)
	for _, name := range names {
		op := table[name]
		if len(op.Funcs) > 1 {
			fmt.Fprintf(out, "\tzc.GenOp(\"%v\",\n", name)
			for _, fn := range op.Funcs {
				fmt.Fprintf(out, "\t\tzc.Func(ops.%v%v),\n", fn.Name, paramTypes(fn.Params))
			}
		} else {
			fn := op.Funcs[0]
			fmt.Fprintf(out, "\tzc.Op(\"%v\", ops.%v%v),\n", name, fn.Name, paramTypes(fn.Params))
		}
	}
	out.WriteString(epilog)
	if err := os.WriteFile("../../pkg/calc/ops_gen.go", []byte(out.String()), 0644); err != nil {
		log.Fatal(err)
	}
}

func paramTypes(params []doc.Param) string {
	if len(params) == 0 {
		return ""
	}
	var inTypes []string
	for _, p := range params {
		if p.All {
			break
		}
		inTypes = append(inTypes, "zc."+p.Type)
	}
	return fmt.Sprintf(", %v", strings.Join(inTypes, ", "))
}
