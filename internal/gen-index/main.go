package main

//go:generate go run main.go ../../doc/index.md

import (
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
	"unicode/utf8"

	"github.com/blackchip-org/zc/v5/pkg/doc"
)

const (
	Root = "../.."
)

type Entry struct {
	Func        string
	Module      string
	Description string
	File        string
	Anchor      string
}

var EntryMap map[string][]Entry
var IndexMainMap map[string]string

func init() {
	EntryMap = make(map[string][]Entry)
	IndexMainMap = make(map[string]string)
}

type qname struct {
	prefix string
	name   string
}

func (n qname) String() string {
	if n.prefix != "" {
		return fmt.Sprintf("%v.%v", n.prefix, n.name)
	}
	return n.name
}

type sortByName []qname

func (s sortByName) Len() int           { return len(s) }
func (s sortByName) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
func (s sortByName) Less(i, j int) bool { return s[i].name < s[j].name }

func main() {
	log.SetFlags(0)

	ops, err := doc.ParseSourceFiles("../../pkg/ops")
	if err != nil {
		log.Fatal(err)
	}
	table := doc.Group(ops)
	var names []qname
	for name := range table {
		parts := strings.SplitN(name, ".", 2)
		if len(parts) == 1 {
			names = append(names, qname{name: parts[0]})
		} else {
			names = append(names, qname{prefix: parts[0], name: parts[1]})
		}
	}
	sort.Sort(sortByName(names))

	out := &strings.Builder{}
	fmt.Fprintf(out, "<!-- Document generated by \"gen-index\"; DO NOT EDIT -->\n\n")
	fmt.Fprint(out, "# index\n\n")

	thisHeading := rune(0)
	for _, q := range names {
		name := q.String()
		heading, _ := utf8.DecodeRuneInString(q.name)
		if ((heading >= 'a' && heading <= 'z') || (heading >= 'A' && heading <= 'Z')) && heading != thisHeading {
			fmt.Fprintf(out, "\n## %v\n\n", string(heading))
			thisHeading = heading
		}
		ops := table[name]
		if name == "+" || name == "-" {
			name = "\\" + name
		}
		if len(ops) == 1 {
			op := ops[0]
			fmt.Fprintf(out, "- [%v](ops/%v.md#%v): %v\n", name, op.Group, op.Name, op.Title)
		} else {
			for _, op := range ops {
				fmt.Fprintf(out, "- [%v](ops/%v.md#%v) (%v): %v\n", name, op.Group, op.Name, op.Group, op.Title)
			}
		}
	}

	if err := os.WriteFile("../../doc/index.md", []byte(out.String()), 0o644); err != nil {
		log.Fatal(err)
	}
}
